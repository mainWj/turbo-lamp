1：自我介绍

2：问主机安全相关，以及介绍一个检测

3：golang中new和make的区别

4：make有几个参数，各个参数的代表什么，有哪些类型。

5:  说说golang切片的理解。

6：GMP模型

7：熟悉的网络模型。

（tcp, udp, icmp, http,https,ssl,重点关注ssl的流程）

8：熟悉的io多路复用模型。

9：进程，线程和协程区别，以及协程是共享堆栈吗？





答 3：

![image-20221116212627361](C:\Users\伍健\AppData\Roaming\Typora\typora-user-images\image-20221116212627361.png)

new 是 Golang 的内建函数，用于分配内存，其中，第一个参数是类型，返回值是类型的指针，其值被初始化为“零”（类型对应的零值，int 初始化为0，bool初始化为 false 等）。

![image-20221116212645344](C:\Users\伍健\AppData\Roaming\Typora\typora-user-images\image-20221116212645344.png)

make 是 Golang 的内建函数，**仅**用于**分配**和**初始化** slice、map 以及 channel 类型的对象，三种类型都是结构。返回值为类型，而不是指针。

1. new 和 make 都用于分配内存；

2. new 和 make 都是在堆上分配内存；

3. new 对指针类型分配内存，返回值是分配类型的指针，new也可以对 slice 、map、channel 分配内存；

4. make 仅用于 slice、map和 channel 的初始化，返回值为类型本身，而不是指针；

原文链接：https://blog.csdn.net/nyist_zxp/article/details/111567784

答4：

make() 是 Go 语言内存分配的内置函数，默认有三个参数。

make(Type, len, cap)
Type：数据类型，必要参数，Type 的值只能是 slice、 map、 channel 这三种数据类型。
len：数据类型实际占用的内存空间长度，map、 channel 是可选参数，slice 是必要参数。
cap：为数据类型提前预留的内存空间长度，可选参数。所谓的提前预留是当前为数据类型申请内存空间的时候，提前申请好额外的内存空间，这样可以避免二次分配内存带来的开销，大大提高程序的性能。
————————————————
原文链接：https://blog.csdn.net/yilovexing/article/details/121172745



答5：

![image-20221116213028276](C:\Users\伍健\AppData\Roaming\Typora\typora-user-images\image-20221116213028276.png)



切片的定义如上。

引用类型就是：变量名储存在栈区，但是变量的值是他所指向的内存地址，需要通过变量所保存的地址去找到指定的内存块，再进行操作。

[https://www.cnblogs.com/lvnux/p/12907356.html?ivk_sa=1024320u#12-%E5%88%87%E7%89%87%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0](https://www.cnblogs.com/lvnux/p/12907356.html?ivk_sa=1024320u#12-切片底层实现)



答6：

- G — 表示 Goroutine，它是一个待执行的任务;

- M — 表示操作系统的线程，它由操作系统的调度器调度和管理;

- P — 表示处理器，它可以被看做运行在线程上的本地调度器.

  ![img](https://upload-images.jianshu.io/upload_images/3630507-c3a983251906ffbd.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

  ##### G与线程区别

  运行时调度器中的地位与线程在操作系统中差不多，占用了更小的内存空间，也降低了上下文切换的开销。
  一个G启动会占用2kB的栈内存，而Linux线程一般是2MB

### M

默认情况下，go创建的线程数=cpu数，每一个线程都对应一个运行时中的 runtime.m 结构体，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销.

最多会有不超过cpu核数的活跃线程正常运行。

##### 状态枚举

- 等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 _Gwaiting、_Gsyscall 和 _Gpreempted 几个状态;
- 可运行：Goroutine已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 _Grunnable;
- 运行中：Goroutine 正在某个线程上运行，即 _Grunning.

### M

默认情况下，go创建的线程数=cpu数，每一个线程都对应一个运行时中的 runtime.m 结构体，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销.

最多会有不超过cpu核数的活跃线程正常运行。

### P

M和G的中间层，提供线程的上下文环境，拥有一个等待运行的goroutine队列，通过p的调度，能在goroutine进行一些I/O操作时及时让出计算资源，提高线程利用率。 数量 = GOMAXPROCS

### 创建goroutine主要流程

1. 获取或者创建新的 Goroutine 结构体, 先向处理器M的gFree列表获取g结构体，没有的话再向P的gFree列表获取，依然没有就会创建一个，分配2kB栈空间;
2. 将传入的参数移到 Goroutine 的栈上;
3. 更新 Goroutine 调度相关的属性。

### 运行队列

Go 语言有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列，运行队列最多可存储256个执行任务，将goroutine放入队列时，如果设置next=true则会插队，M下一次会执行这个g。

### 调度循环过程

##### schedule查找待执行的goroutine

1. 为保证公平,当全局队列有待执行的goroutine时,会有一定几率从全局队列中查找goroutine.
2. 从本地队列中查找待执行的goroutine.
3. 如果前两种都找不到,会尝试从其他P偷取G, 偷不到就会阻塞等待.
4. 获取到goroutine后,设置g的状态.
5. 执行函数.
6. 函数结束后,goroutine重新加入M的gFree列表.

##### 触发调度

调度器的 runtime.schedule 会重新选择 Goroutine 在线程上执行, 函数的调用点如下:

###### 主动挂起,channel

1. 切换到g0将挂起的goroutine状态切换为waiting, 移除线程和goroutine之间的关系, 调用schedule触发新一轮调度.
2. goroutine等待的条件满足后, 运行时会调用ready唤醒该g, 状态切换为可执行加入到运行队列.

###### 阻塞调用 I/O操作

M和P分离, P由其他空闲的或者新创建一个M来接管, 原来的M和G进入睡眠等待唤醒.

###### 抢占式

goroutine调度时间超过10ms,会发生抢占. 防止其他g被饿死.

##### go func()过程

1. 获取或者创建新的 Goroutine 结构体, 先向处理器M的gFree列表获取g结构体,没有的话再向P的gFree列表获取,依然没有就会创建一个.
2. 将传入的参数移到 Goroutine 的栈上;
3. 更新 Goroutine 调度相关的属性.
4. 尝试把G放入一个P的调度队列, 如果队列均为满, 则会放入全局队列.
5. g执行超过10ms,发生抢占,重新放入p的等待队列.
6. g执行完毕, 变成空闲状态, 放入M或者P的gFree列表.
7. M运行G0, 运行schedule函数进行下一次调度.

### M0 与 G0

- M0是运行时的第一个线程,启动第一个G(main),然后就会其他M一样
- 每个M启动后,都会创建一个G0,G0用于负责调度其他的G,不执行任何函数,
- M要使用G0来进行schedule.
  链接：https://www.jianshu.com/p/24d2db028ab6
